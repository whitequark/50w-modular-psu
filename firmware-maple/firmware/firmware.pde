#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <alloca.h>

#include <timer.h>
#include <spi.h>

#define IRQ(x) extern "C" void x()

const char font[][6] = {
  {0x00,0x00,0x00,0x00,0x00,0x00},   //   0x20 32
  {0x00,0x00,0x00,0x6f,0x00,0x00},   // ! 0x21 33
  {0x00,0x00,0x07,0x00,0x07,0x00},   // " 0x22 34
  {0x00,0x14,0x7f,0x14,0x7f,0x14},   // # 0x23 35
  {0x00,0x00,0x07,0x04,0x1e,0x00},   // $ 0x24 36
  {0x00,0x23,0x13,0x08,0x64,0x62},   // % 0x25 37
  {0x00,0x36,0x49,0x56,0x20,0x50},   // & 0x26 38
  {0x00,0x00,0x00,0x07,0x00,0x00},   // ' 0x27 39
  {0x00,0x00,0x1c,0x22,0x41,0x00},   // ( 0x28 40
  {0x00,0x00,0x41,0x22,0x1c,0x00},   // ) 0x29 41
  {0x00,0x14,0x08,0x3e,0x08,0x14},   // * 0x2a 42
  {0x00,0x08,0x08,0x3e,0x08,0x08},   // + 0x2b 43
  {0x00,0x00,0x50,0x30,0x00,0x00},   // , 0x2c 44
  {0x00,0x08,0x08,0x08,0x08,0x08},   // - 0x2d 45
  {0x00,0x00,0x60,0x60,0x00,0x00},   // . 0x2e 46
  {0x00,0x20,0x10,0x08,0x04,0x02},   // / 0x2f 47
  {0x00,0x3e,0x51,0x49,0x45,0x3e},   // 0 0x30 48
  {0x00,0x00,0x42,0x7f,0x40,0x00},   // 1 0x31 49
  {0x00,0x42,0x61,0x51,0x49,0x46},   // 2 0x32 50
  {0x00,0x21,0x41,0x45,0x4b,0x31},   // 3 0x33 51
  {0x00,0x18,0x14,0x12,0x7f,0x10},   // 4 0x34 52
  {0x00,0x27,0x45,0x45,0x45,0x39},   // 5 0x35 53
  {0x00,0x3c,0x4a,0x49,0x49,0x30},   // 6 0x36 54
  {0x00,0x01,0x71,0x09,0x05,0x03},   // 7 0x37 55
  {0x00,0x36,0x49,0x49,0x49,0x36},   // 8 0x38 56
  {0x00,0x06,0x49,0x49,0x29,0x1e},   // 9 0x39 57
  {0x00,0x00,0x36,0x36,0x00,0x00},   // : 0x3a 58
  {0x00,0x00,0x56,0x36,0x00,0x00},   // ; 0x3b 59
  {0x00,0x08,0x14,0x22,0x41,0x00},   // < 0x3c 60
  {0x00,0x14,0x14,0x14,0x14,0x14},   // = 0x3d 61
  {0x00,0x00,0x41,0x22,0x14,0x08},   // > 0x3e 62
  {0x00,0x02,0x01,0x51,0x09,0x06},   // ? 0x3f 63
  {0x00,0x3e,0x41,0x5d,0x49,0x4e},   // @ 0x40 64
  {0x00,0x7e,0x09,0x09,0x09,0x7e},   // A 0x41 65
  {0x00,0x7f,0x49,0x49,0x49,0x36},   // B 0x42 66
  {0x00,0x3e,0x41,0x41,0x41,0x22},   // C 0x43 67
  {0x00,0x7f,0x41,0x41,0x41,0x3e},   // D 0x44 68
  {0x00,0x7f,0x49,0x49,0x49,0x41},   // E 0x45 69
  {0x00,0x7f,0x09,0x09,0x09,0x01},   // F 0x46 70
  {0x00,0x3e,0x41,0x49,0x49,0x7a},   // G 0x47 71
  {0x00,0x7f,0x08,0x08,0x08,0x7f},   // H 0x48 72
  {0x00,0x00,0x41,0x7f,0x41,0x00},   // I 0x49 73
  {0x00,0x20,0x40,0x41,0x3f,0x01},   // J 0x4a 74
  {0x00,0x7f,0x08,0x14,0x22,0x41},   // K 0x4b 75
  {0x00,0x7f,0x40,0x40,0x40,0x40},   // L 0x4c 76
  {0x00,0x7f,0x02,0x0c,0x02,0x7f},   // M 0x4d 77
  {0x00,0x7f,0x04,0x08,0x10,0x7f},   // N 0x4e 78
  {0x00,0x3e,0x41,0x41,0x41,0x3e},   // O 0x4f 79
  {0x00,0x7f,0x09,0x09,0x09,0x06},   // P 0x50 80
  {0x00,0x3e,0x41,0x51,0x21,0x5e},   // Q 0x51 81
  {0x00,0x7f,0x09,0x19,0x29,0x46},   // R 0x52 82
  {0x00,0x46,0x49,0x49,0x49,0x31},   // S 0x53 83
  {0x00,0x01,0x01,0x7f,0x01,0x01},   // T 0x54 84
  {0x00,0x3f,0x40,0x40,0x40,0x3f},   // U 0x55 85
  {0x00,0x0f,0x30,0x40,0x30,0x0f},   // V 0x56 86
  {0x00,0x3f,0x40,0x30,0x40,0x3f},   // W 0x57 87
  {0x00,0x63,0x14,0x08,0x14,0x63},   // X 0x58 88
  {0x00,0x07,0x08,0x70,0x08,0x07},   // Y 0x59 89
  {0x00,0x61,0x51,0x49,0x45,0x43},   // Z 0x5a 90
  {0x00,0x3c,0x4a,0x49,0x29,0x1e},   // [ 0x5b 91
  {0x00,0x02,0x04,0x08,0x10,0x20},   // \ 0x5c 92
  {0x00,0x00,0x41,0x7f,0x00,0x00},   // ] 0x5d 93
  {0x00,0x04,0x02,0x01,0x02,0x04},   // ^ 0x5e 94
  {0x00,0x40,0x40,0x40,0x40,0x40},   // _ 0x5f 95
  {0x00,0x00,0x00,0x03,0x04,0x00},   // ` 0x60 96
  {0x00,0x20,0x54,0x54,0x54,0x78},   // a 0x61 97
  {0x00,0x7f,0x48,0x44,0x44,0x38},   // b 0x62 98
  {0x00,0x38,0x44,0x44,0x44,0x20},   // c 0x63 99
  {0x00,0x38,0x44,0x44,0x48,0x7f},   // d 0x64 100
  {0x00,0x38,0x54,0x54,0x54,0x18},   // e 0x65 101
  {0x00,0x08,0x7e,0x09,0x01,0x02},   // f 0x66 102
  {0x00,0x0c,0x52,0x52,0x52,0x3e},   // g 0x67 103
  {0x00,0x7f,0x08,0x04,0x04,0x78},   // h 0x68 104
  {0x00,0x00,0x44,0x7d,0x40,0x00},   // i 0x69 105
  {0x00,0x20,0x40,0x44,0x3d,0x00},   // j 0x6a 106
  {0x00,0x00,0x7f,0x10,0x28,0x44},   // k 0x6b 107
  {0x00,0x00,0x41,0x7f,0x40,0x00},   // l 0x6c 108
  {0x00,0x7c,0x04,0x18,0x04,0x78},   // m 0x6d 109
  {0x00,0x7c,0x08,0x04,0x04,0x78},   // n 0x6e 110
  {0x00,0x38,0x44,0x44,0x44,0x38},   // o 0x6f 111
  {0x00,0x7c,0x14,0x14,0x14,0x08},   // p 0x70 112
  {0x00,0x08,0x14,0x14,0x18,0x7c},   // q 0x71 113
  {0x00,0x7c,0x08,0x04,0x04,0x08},   // r 0x72 114
  {0x00,0x48,0x54,0x54,0x54,0x20},   // s 0x73 115
  {0x00,0x04,0x3f,0x44,0x40,0x20},   // t 0x74 116
  {0x00,0x3c,0x40,0x40,0x20,0x7c},   // u 0x75 117
  {0x00,0x1c,0x20,0x40,0x20,0x1c},   // v 0x76 118
  {0x00,0x3c,0x40,0x30,0x40,0x3c},   // w 0x77 119
  {0x00,0x44,0x28,0x10,0x28,0x44},   // x 0x78 120
  {0x00,0x0c,0x50,0x50,0x50,0x3c},   // y 0x79 121
  {0x00,0x44,0x64,0x54,0x4c,0x44},   // z 0x7a 122
  {0x00,0x00,0x08,0x36,0x41,0x41},   // { 0x7b 123
  {0x00,0x00,0x00,0x7f,0x00,0x00},   // | 0x7c 124
  {0x00,0x41,0x41,0x36,0x08,0x00},   // } 0x7d 125
  {0x00,0x04,0x02,0x04,0x08,0x04},   // ~ 0x7e 126
};

void lcd_write(int is_data, uint8 val) {
  gpio_write_bit(GPIOA, 5, 0); // sclk low
  gpio_write_bit(GPIOB, 7, 0); // cs low
  delay_us(1);
  gpio_write_bit(GPIOA, 7, is_data);
  gpio_write_bit(GPIOA, 5, 1); // sclk high
  delay_us(1);
   
  for(int i = 0; i < 8; i++) {
    gpio_write_bit(GPIOA, 5, false); // sclk low
    gpio_write_bit(GPIOA, 7, val & 0x80);
    delay_us(1);
    gpio_write_bit(GPIOA, 5, true); // sclk high
    delay_us(1);
    
    val <<= 1;
  }

  gpio_write_bit(GPIOB, 7, 1); // cs high
}

void lcd_init() {
  gpio_write_bit(GPIOA, 10, 0);
  delay_us(8);
  gpio_write_bit(GPIOA, 10, 1);
  delay_us(8);

  lcd_write(0, 0x11); // sleep out

  lcd_write(0, 0x36); // memory mode
  lcd_write(1, 0xc0); // invert X/Y

  lcd_write(0, 0x3A); // color mode
  lcd_write(1, 0x05); // 16bpp

  lcd_write(0, 0x29); // display on
}

void lcd_start() {
  lcd_write(0, 0x2c);
}

void lcd_finish() {
  lcd_write(0, 0x00);
}

void lcd_clip(int x1, int y1, int x2, int y2) {
  lcd_write(0, 0x2a); // set columns
  lcd_write(1, x1);
  lcd_write(1, x2);

  lcd_write(0, 0x2b); // set rows
  lcd_write(1, y1);
  lcd_write(1, y2);
}

void lcd_put(int color) {
  lcd_write(1, color >> 8);
  lcd_write(1, color & 0xff);
}

void lcd_clear(int color) {
  lcd_clip(2, 2, 130, 130);
  lcd_start();
  for(int i = 0; i < 128*128; i++) lcd_put(color);
  lcd_finish();
}

const int font_width = sizeof(font[0]);
void lcd_text(uint16 bg, uint16 fg, int x, int y, const char *str) {
  int len = strlen(str);
  lcd_clip(x, y, x + len * font_width - 1, y + 7);
  lcd_start();
  for(int j = 0; j < 8; j++) {
    for(int i = 0; i < len * font_width; i++) {
      char c = str[i / font_width];
      if(font[c - ' '][i % font_width] & (1 << j))
        lcd_put(fg);
      else
        lcd_put(bg);
    }
  }
  lcd_finish();
}

void lcd_printf(uint16 bg, uint16 fg, int x, int y, int w, const char *fmt, ...) {
  va_list vl;
  va_start(vl, fmt);
  char *display = (char*) alloca(w + 1);
  memset(display, 0, w + 1);
  vsnprintf(display, w + 1, fmt, vl);
  memset(display + strlen(display), 0x20, w - strlen(display));
  lcd_text(bg, fg, x, y, display);
  va_end(vl);
}

void update_freq();
void update_status();

void spi_reset() {
  spi_init(SPI2);
  SPI2_BASE->CR1 = SPI_CR1_MSTR | SPI_CR1_BR_PCLK_DIV_64 | SPI_CR1_CPHA | SPI_CR1_DFF_16_BIT;
  SPI2_BASE->CR2 = SPI_CR2_SSOE;
  spi_irq_enable(SPI2, SPI_RXNE_INTERRUPT);
}

void setup() {
  afio_init();
  gpio_init(GPIOA);
  gpio_init(GPIOB);
  gpio_init(GPIOC);
  timer_init(TIMER1);
  
  /* lcd */
  gpio_set_mode(GPIOB, 7, GPIO_OUTPUT_PP); // cs
  gpio_write_bit(GPIOB, 7, 1);
  gpio_set_mode(GPIOA, 10, GPIO_OUTPUT_PP); // reset
  gpio_set_mode(GPIOA, 7, GPIO_OUTPUT_PP); // mosi
  gpio_set_mode(GPIOA, 5, GPIO_OUTPUT_PP); // sck

  /* backlight */
  gpio_set_mode(GPIOA, 4, GPIO_OUTPUT_PP);
  gpio_write_bit(GPIOA, 4, 1);
  
  /* joystick */
  gpio_set_mode(GPIOC, 0, GPIO_INPUT_PU);
  gpio_write_bit(GPIOC, 0, 1);
  gpio_set_mode(GPIOC, 1, GPIO_INPUT_PU);
  gpio_write_bit(GPIOC, 1, 1);
  gpio_set_mode(GPIOC, 2, GPIO_INPUT_PU);
  gpio_write_bit(GPIOC, 2, 1);
  gpio_set_mode(GPIOC, 3, GPIO_INPUT_PU);
  gpio_write_bit(GPIOC, 3, 1);
  gpio_set_mode(GPIOC, 4, GPIO_INPUT_PU);
  gpio_write_bit(GPIOC, 4, 1);
  
  /* spi */
  AFIO_BASE->MAPR |= AFIO_MAPR_TIM1_REMAP_PARTIAL; // remap TIM1 away
  gpio_set_mode(GPIOB, 12, GPIO_OUTPUT_PP); // cs
  gpio_write_bit(GPIOB, 12, 1);
  gpio_set_mode(GPIOB, 13, GPIO_AF_OUTPUT_PP); // sck
  gpio_set_mode(GPIOB, 14, GPIO_INPUT_FLOATING); // miso
  gpio_set_mode(GPIOB, 15, GPIO_AF_OUTPUT_PP); // mosi
  spi_reset();

  /* PWM out */
  gpio_set_mode(GPIOA, 8, GPIO_AF_OUTPUT_PP);
  timer_adv_reg_map *regs = (TIMER1->regs).adv;
  regs->BDTR = TIMER_BDTR_MOE | TIMER_BDTR_LOCK_OFF;
  timer_set_prescaler(TIMER1, 0);
  timer_set_reload(TIMER1, 72000000/(80000*2));
  timer_oc_set_mode(TIMER1, TIMER_CH1, TIMER_OC_MODE_TOGGLE, TIMER_OC_PE);    
  timer_cc_enable(TIMER1, TIMER_CH1);
  timer_pause(TIMER1);
  
  /* subsystems */
  lcd_init();
  lcd_clear(0xffff);
  lcd_text(0xffff, 0x0000, 10, 10, "status:");
  update_status();
  lcd_text(0xffff, 0x0000, 10, 30, "frequency:");
  update_freq();
}

static inline int timer_status(timer_dev *dev) {
  return *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT);
}

void update_status() {
  if(timer_status(TIMER1)) {
    lcd_text(0xffff, 0x03e0, 10, 19, "ON ");
  } else {
    lcd_text(0xffff, 0xf800, 10, 19, "OFF");
  }
}

void update_freq() {
  int freq = 72000000/((timer_get_reload(TIMER1)+1)*2);
  lcd_printf(0xffff, 0xf800, 10, 39, 14, "%d.%d kHz", freq/1000,freq%1000);
}

const int adc_ringbuf_size = 256;
uint16 adc_ringbuf[adc_ringbuf_size] = {0};
uint8 adc_ringbuf_pos = 0;
volatile uint16 adc_data = 0, adc_data_old = 0;
volatile int adc_dead = 1;
IRQ(__irq_spi2) {
  uint16 val = spi_rx_reg(SPI2);
  gpio_write_bit(GPIOB, 12, 1);
  spi_peripheral_disable(SPI2);

  if(val & 0xf000) {
    adc_dead = 1;
  } else {
    adc_dead = 0;
    adc_ringbuf[adc_ringbuf_pos++ % adc_ringbuf_size] = spi_rx_reg(SPI2);

    uint32 sum = 0;
    for(int i = 0; i < adc_ringbuf_size; i++) sum += adc_ringbuf[i];
    adc_data_old = adc_data;
    adc_data = sum / adc_ringbuf_size;
  }
}

static uint32 debounce = 0;

void loop() {
  if(debounce < systick_uptime_millis) {
    if(!gpio_read_bit(GPIOC, 1) || !gpio_read_bit(GPIOC, 4)) { // bottom, top
      int adjust = (!gpio_read_bit(GPIOC, 1)) ? -1 : 1;
      int reload = timer_get_reload(TIMER1);
      reload += adjust;
      timer_set_reload(TIMER1, reload);

      update_freq();
      debounce = systick_uptime_millis + 10;
    } else if(!gpio_read_bit(GPIOC, 3)) { // center
      if(!timer_status(TIMER1)) timer_resume(TIMER1);
      else timer_pause(TIMER1);
      update_status();
      debounce = systick_uptime_millis + 800;
    }
  }

  if(spi_is_tx_empty(SPI2)) {
    gpio_write_bit(GPIOB, 12, 0);
    spi_peripheral_enable(SPI2);
    spi_tx_reg(SPI2, 0x3300);
  }

  if(adc_dead) {
    lcd_text(0xffff, 0xf800, 10, 60, "DEAD");
    adc_data_old = 0;
  } else if(adc_data_old != adc_data) {
    lcd_printf(0xffff, 0x001f, 10, 60, 9, "%03x  %04x", adc_data, SPI2_BASE->SR);
    adc_data_old = adc_data;
  }

  if(SPI2_BASE->SR == 0x00) {
    spi_reset();
  }
}
